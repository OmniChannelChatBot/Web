/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export interface IOAuthApiServiceClient {
    /**
     * @return Sign up
     */
    signUp(body: SignUpCommand): Promise<number>;
    /**
     * @return Sign in
     */
    signIn(body: SignInCommand): Promise<SignInCommandResponse>;
    /**
     * @return Refreshed
     */
    refreshAccessToken(body: RefreshAccessTokenCommand): Promise<RefreshAccessTokenCommandResponse>;
    /**
     * @return Success
     */
    test(): Promise<void>;
}

export class OAuthApiServiceClient implements IOAuthApiServiceClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Sign up
     */
    signUp(body: SignUpCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Auth/sign-up";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSignUp(_response);
        });
    }

    protected processSignUp(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status === 504) {
            const _responseText = response.data;
            let result504: any = null;
            let resultData504  = _responseText;
            result504 = ApiProblemDetails.fromJS(resultData504);
            return throwException("Gateway Timeout", status, _responseText, _headers, result504);
        } else if (status === 503) {
            const _responseText = response.data;
            let result503: any = null;
            let resultData503  = _responseText;
            result503 = ApiProblemDetails.fromJS(resultData503);
            return throwException("Service Unavailable", status, _responseText, _headers, result503);
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502  = _responseText;
            result502 = ApiProblemDetails.fromJS(resultData502);
            return throwException("Bad Gateway", status, _responseText, _headers, result502);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = ApiProblemDetails.fromJS(resultData501);
            return throwException("Not Implemented", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
        } else if (status === 415) {
            const _responseText = response.data;
            let result415: any = null;
            let resultData415  = _responseText;
            result415 = ApiProblemDetails.fromJS(resultData415);
            return throwException("Unsupported Media Type", status, _responseText, _headers, result415);
        } else if (status === 413) {
            const _responseText = response.data;
            let result413: any = null;
            let resultData413  = _responseText;
            result413 = ApiProblemDetails.fromJS(resultData413);
            return throwException("Payload Too Large", status, _responseText, _headers, result413);
        } else if (status === 412) {
            const _responseText = response.data;
            let result412: any = null;
            let resultData412  = _responseText;
            result412 = ApiProblemDetails.fromJS(resultData412);
            return throwException("Precondition Failed", status, _responseText, _headers, result412);
        } else if (status === 405) {
            const _responseText = response.data;
            let result405: any = null;
            let resultData405  = _responseText;
            result405 = ApiProblemDetails.fromJS(resultData405);
            return throwException("Method Not Allowed", status, _responseText, _headers, result405);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @return Sign in
     */
    signIn(body: SignInCommand): Promise<SignInCommandResponse> {
        let url_ = this.baseUrl + "/api/Auth/sign-in";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: AxiosResponse): Promise<SignInCommandResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SignInCommandResponse.fromJS(resultData200);
            return result200;
        } else if (status === 504) {
            const _responseText = response.data;
            let result504: any = null;
            let resultData504  = _responseText;
            result504 = ApiProblemDetails.fromJS(resultData504);
            return throwException("Gateway Timeout", status, _responseText, _headers, result504);
        } else if (status === 503) {
            const _responseText = response.data;
            let result503: any = null;
            let resultData503  = _responseText;
            result503 = ApiProblemDetails.fromJS(resultData503);
            return throwException("Service Unavailable", status, _responseText, _headers, result503);
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502  = _responseText;
            result502 = ApiProblemDetails.fromJS(resultData502);
            return throwException("Bad Gateway", status, _responseText, _headers, result502);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = ApiProblemDetails.fromJS(resultData501);
            return throwException("Not Implemented", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
        } else if (status === 415) {
            const _responseText = response.data;
            let result415: any = null;
            let resultData415  = _responseText;
            result415 = ApiProblemDetails.fromJS(resultData415);
            return throwException("Unsupported Media Type", status, _responseText, _headers, result415);
        } else if (status === 413) {
            const _responseText = response.data;
            let result413: any = null;
            let resultData413  = _responseText;
            result413 = ApiProblemDetails.fromJS(resultData413);
            return throwException("Payload Too Large", status, _responseText, _headers, result413);
        } else if (status === 412) {
            const _responseText = response.data;
            let result412: any = null;
            let resultData412  = _responseText;
            result412 = ApiProblemDetails.fromJS(resultData412);
            return throwException("Precondition Failed", status, _responseText, _headers, result412);
        } else if (status === 405) {
            const _responseText = response.data;
            let result405: any = null;
            let resultData405  = _responseText;
            result405 = ApiProblemDetails.fromJS(resultData405);
            return throwException("Method Not Allowed", status, _responseText, _headers, result405);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SignInCommandResponse>(<any>null);
    }

    /**
     * @return Refreshed
     */
    refreshAccessToken(body: RefreshAccessTokenCommand): Promise<RefreshAccessTokenCommandResponse> {
        let url_ = this.baseUrl + "/api/Auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processRefreshAccessToken(_response);
        });
    }

    protected processRefreshAccessToken(response: AxiosResponse): Promise<RefreshAccessTokenCommandResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefreshAccessTokenCommandResponse.fromJS(resultData200);
            return result200;
        } else if (status === 504) {
            const _responseText = response.data;
            let result504: any = null;
            let resultData504  = _responseText;
            result504 = ApiProblemDetails.fromJS(resultData504);
            return throwException("Gateway Timeout", status, _responseText, _headers, result504);
        } else if (status === 503) {
            const _responseText = response.data;
            let result503: any = null;
            let resultData503  = _responseText;
            result503 = ApiProblemDetails.fromJS(resultData503);
            return throwException("Service Unavailable", status, _responseText, _headers, result503);
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502  = _responseText;
            result502 = ApiProblemDetails.fromJS(resultData502);
            return throwException("Bad Gateway", status, _responseText, _headers, result502);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = ApiProblemDetails.fromJS(resultData501);
            return throwException("Not Implemented", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
        } else if (status === 415) {
            const _responseText = response.data;
            let result415: any = null;
            let resultData415  = _responseText;
            result415 = ApiProblemDetails.fromJS(resultData415);
            return throwException("Unsupported Media Type", status, _responseText, _headers, result415);
        } else if (status === 413) {
            const _responseText = response.data;
            let result413: any = null;
            let resultData413  = _responseText;
            result413 = ApiProblemDetails.fromJS(resultData413);
            return throwException("Payload Too Large", status, _responseText, _headers, result413);
        } else if (status === 412) {
            const _responseText = response.data;
            let result412: any = null;
            let resultData412  = _responseText;
            result412 = ApiProblemDetails.fromJS(resultData412);
            return throwException("Precondition Failed", status, _responseText, _headers, result412);
        } else if (status === 405) {
            const _responseText = response.data;
            let result405: any = null;
            let resultData405  = _responseText;
            result405 = ApiProblemDetails.fromJS(resultData405);
            return throwException("Method Not Allowed", status, _responseText, _headers, result405);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefreshAccessTokenCommandResponse>(<any>null);
    }

    /**
     * @return Success
     */
    test(): Promise<void> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTest(_response);
        });
    }

    protected processTest(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);
        } else if (status === 504) {
            const _responseText = response.data;
            let result504: any = null;
            let resultData504  = _responseText;
            result504 = ApiProblemDetails.fromJS(resultData504);
            return throwException("Gateway Timeout", status, _responseText, _headers, result504);
        } else if (status === 503) {
            const _responseText = response.data;
            let result503: any = null;
            let resultData503  = _responseText;
            result503 = ApiProblemDetails.fromJS(resultData503);
            return throwException("Service Unavailable", status, _responseText, _headers, result503);
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502  = _responseText;
            result502 = ApiProblemDetails.fromJS(resultData502);
            return throwException("Bad Gateway", status, _responseText, _headers, result502);
        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = ApiProblemDetails.fromJS(resultData501);
            return throwException("Not Implemented", status, _responseText, _headers, result501);
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ApiProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
        } else if (status === 415) {
            const _responseText = response.data;
            let result415: any = null;
            let resultData415  = _responseText;
            result415 = ApiProblemDetails.fromJS(resultData415);
            return throwException("Unsupported Media Type", status, _responseText, _headers, result415);
        } else if (status === 413) {
            const _responseText = response.data;
            let result413: any = null;
            let resultData413  = _responseText;
            result413 = ApiProblemDetails.fromJS(resultData413);
            return throwException("Payload Too Large", status, _responseText, _headers, result413);
        } else if (status === 412) {
            const _responseText = response.data;
            let result412: any = null;
            let resultData412  = _responseText;
            result412 = ApiProblemDetails.fromJS(resultData412);
            return throwException("Precondition Failed", status, _responseText, _headers, result412);
        } else if (status === 405) {
            const _responseText = response.data;
            let result405: any = null;
            let resultData405  = _responseText;
            result405 = ApiProblemDetails.fromJS(resultData405);
            return throwException("Method Not Allowed", status, _responseText, _headers, result405);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ApiProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export enum UserType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class SignUpCommand implements ISignUpCommand {
    username!: string;
    firstName!: string;
    lastName!: string;
    password!: string;
    email!: string;
    type!: UserType;

    constructor(data?: ISignUpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SignUpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        data["email"] = this.email;
        data["type"] = this.type;
        return data; 
    }
}

export interface ISignUpCommand {
    username: string;
    firstName: string;
    lastName: string;
    password: string;
    email: string;
    type: UserType;
}

export class ApiProblemDetails implements IApiProblemDetails {
    readonly traceId?: string | undefined;
    readonly errors?: { [key: string]: string[]; } | undefined;
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IApiProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).traceId = _data["traceId"];
            if (_data["errors"]) {
                (<any>this).errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this).errors![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ApiProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ApiProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["traceId"] = this.traceId;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    data["errors"][key] = this.errors[key];
            }
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IApiProblemDetails {
    traceId?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class SignInCommand implements ISignInCommand {
    username!: string;
    password!: string;

    constructor(data?: ISignInCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignInCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SignInCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }
}

export interface ISignInCommand {
    username: string;
    password: string;
}

export class SignInCommandResponse implements ISignInCommandResponse {
    accessToken!: string;
    refreshToken!: string;

    constructor(data?: ISignInCommandResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): SignInCommandResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SignInCommandResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface ISignInCommandResponse {
    accessToken: string;
    refreshToken: string;
}

export class RefreshAccessTokenCommand implements IRefreshAccessTokenCommand {
    accessToken!: string;
    refreshToken!: string;

    constructor(data?: IRefreshAccessTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshAccessTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshAccessTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface IRefreshAccessTokenCommand {
    accessToken: string;
    refreshToken: string;
}

export class RefreshAccessTokenCommandResponse implements IRefreshAccessTokenCommandResponse {
    accessToken!: string;
    refreshToken!: string;

    constructor(data?: IRefreshAccessTokenCommandResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshAccessTokenCommandResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshAccessTokenCommandResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface IRefreshAccessTokenCommandResponse {
    accessToken: string;
    refreshToken: string;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}